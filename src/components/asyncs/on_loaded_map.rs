use std::{cell::RefCell, marker::PhantomData, rc::Rc};

use crate::{components::Context, Component};

pub struct AsyncComp<Async, OutState, Child> {
    _async: PhantomData<Async>,
    _state: PhantomData<OutState>,
    _component: PhantomData<Child>,
}
impl<Async, OutState, Child: for<'a> Component<&'a OutState, &'a mut OutState>>
    AsyncComp<Async, OutState, Child>
{
    /// builds the component as is, without any mapping
    pub fn build<'a>(a: <Child as Component<&'a OutState, &'a mut OutState>>::Input) -> Child {
        Child::instantiate(a)
    }
    /// Configure the function needed to go from State A to the properties needed for Component B

    pub fn map_in<StateIn, Func: Fn(Rc<RefCell<Async>>, bool, &StateIn) -> OutState>(
        func: Func,
    ) -> MapInto<Async, StateIn, OutState, Child, Func> {
        MapInto {
            _component: PhantomData,
            _state_in: PhantomData,
            _state_out: PhantomData,
            _async: PhantomData,
            func,
        }
    }
}
/// constructed by [Comp<State,Component>::map_in](crate::components::Comp)
///
/// Allows you to construct the component by setting how the output of the Component maps back into the given state
pub struct MapInto<Async, FullStateIn, StateOut, Comp, Map> {
    _state_in: PhantomData<FullStateIn>,
    _state_out: PhantomData<StateOut>,
    _component: PhantomData<Comp>,
    _async: PhantomData<Async>,
    func: Map,
}
impl<
        Async,
        Comp: for<'a> Component<&'a StateOut, &'a mut StateOut>,
        FullStateIn,
        StateOut,
        MapIn: Fn(Rc<RefCell<Async>>, bool, &FullStateIn) -> StateOut,
    > MapInto<Async, FullStateIn, StateOut, Comp, MapIn>
{
    /// constructs the component with the given initialized data
    pub fn map_out_with<'a, FuncOut: Fn(StateOut, &mut FullStateIn)>(
        self,
        input: <Comp as Component<&'a StateOut, &'a mut StateOut>>::Input,
        func: FuncOut,
    ) -> AsyncSelector<MapIn, FuncOut, Comp> {
        AsyncSelector::new(self.func, func, Comp::instantiate(input))
    }
    ///uses an already existing component
    pub fn map_out_for<FuncOut: Fn(StateOut, &mut FullStateIn)>(
        self,
        func: FuncOut,
        child: Comp,
    ) -> AsyncSelector<MapIn, FuncOut, Comp> {
        AsyncSelector::new(self.func, func, child)
    }
    /// constructs the component using the default data for its initialized data
    pub fn map_out<'a, FuncOut: Fn(StateOut, &mut FullStateIn)>(
        self,
        func: FuncOut,
    ) -> AsyncSelector<MapIn, FuncOut, Comp>
    where
        StateOut: 'a,
        <Comp as Component<&'a StateOut, &'a mut StateOut>>::Input: Default,
    {
        AsyncSelector::new(self.func, func, Comp::instantiate(Default::default()))
    }
}

/// This component acts as a map between the properties of its child node and the current state
///
/// It maps both ways so updates to the state generated by the child can be applied to the main state
pub struct AsyncSelector<MapFunc, Updater, Child> {
    updater: Updater,
    mapper: MapFunc,
    child: Child,
}
impl<
        Async,
        FullStateIn,
        StateOut,
        MapFunc: Fn(Rc<RefCell<Async>>, bool, &FullStateIn) -> StateOut,
        Updater: Fn(StateOut, &mut FullStateIn),
        Child: for<'a> Component<&'a StateOut, &'a mut StateOut>,
    >
    Component<
        &(Rc<RefCell<Async>>, bool, &FullStateIn),
        &mut (Rc<RefCell<Async>>, bool, &mut FullStateIn),
    > for AsyncSelector<MapFunc, Updater, Child>
{
    fn process<'c, 'd>(
        &mut self,
        context: &Context,
        state: &'c mut (Rc<RefCell<Async>>, bool, &'d mut FullStateIn),
    ) -> &'c mut (Rc<RefCell<Async>>, bool, &'d mut FullStateIn) {
        let mut mapped_state = (self.mapper)(state.0.to_owned(), state.1, state.2);
        self.child.process(context, &mut mapped_state);
        (self.updater)(mapped_state, state.2);
        state
    }

    fn render(&self, context: &Context, props: &(Rc<RefCell<Async>>, bool, &FullStateIn)) {
        let mapped_state = (self.mapper)(props.0.to_owned(), props.1, props.2);
        self.child.render(context, &mapped_state)
    }

    type Input = (MapFunc, Updater, Child);

    fn instantiate(input: Self::Input) -> Self {
        Self::new(input.0, input.1, input.2)
    }
    fn ui<'c, 'd>(
        &mut self,
        context: &Context,
        ui: &mut macroquad::ui::Ui,
        state: &'c mut (Rc<RefCell<Async>>, bool, &'d mut FullStateIn),
    ) -> &'c mut (Rc<RefCell<Async>>, bool, &'d mut FullStateIn) {
        let mut mapped_state = (self.mapper)(state.0.to_owned(), state.1, state.2);
        self.child.ui(context, ui, &mut mapped_state);
        (self.updater)(mapped_state, state.2);
        state
    }
}
impl<MapFunc, Updater, Child> AsyncSelector<MapFunc, Updater, Child> {
    pub fn new(map: MapFunc, updater: Updater, child: Child) -> Self {
        Self {
            updater,
            mapper: map,
            child,
        }
    }
}
