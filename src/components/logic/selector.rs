use crate::{components::Context, Component};
/// This component acts as a map between the properties of its child node and the current state
///
/// It maps both ways so updates to the state generated by the child can be applied to the main state
pub struct Selector<MapFunc, Updater, Child> {
    updater: Updater,
    mapper: MapFunc,
    child: Child,
}
impl<
        StateIn,
        StateOut,
        MapFunc: Fn(&StateIn) -> StateOut,
        Updater: Fn(StateOut, &mut StateIn),
        Child: for<'a> Component<&'a StateOut, &'a mut StateOut>,
    > Component<&StateIn, &mut StateIn> for Selector<MapFunc, Updater, Child>
{
    fn process<'c>(&mut self, context: &Context, state: &'c mut StateIn) -> &'c mut StateIn {
        let mut mapped_state = (self.mapper)(state);
        self.child.process(context, &mut mapped_state);
        (self.updater)(mapped_state, state);
        state
    }

    fn render(&self, context: &Context, props: &StateIn) {
        let mapped_state = (self.mapper)(props);
        self.child.render(context, &mapped_state)
    }

    type Input = (MapFunc, Updater, Child);

    fn instantiate(input: Self::Input) -> Self {
        Self::new(input.0, input.1, input.2)
    }
    fn ui<'c>(
        &mut self,
        context: &Context,
        ui: &mut macroquad::ui::Ui,
        state: &'c mut StateIn,
    ) -> &'c mut StateIn {
        let mut mapped_state = (self.mapper)(state);
        self.child.ui(context, ui, &mut mapped_state);
        (self.updater)(mapped_state, state);
        state
    }
}
impl<MapFunc, Updater, Child> Selector<MapFunc, Updater, Child> {
    pub fn new(map: MapFunc, updater: Updater, child: Child) -> Self {
        Self {
            updater,
            mapper: map,
            child,
        }
    }
}
