use std::marker::PhantomData;

use crate::Component;
/// This component acts as a map between the properties of its child node and the current state
///
/// It maps both ways so updates to the state generated by the child can be applied to the main state
pub struct Selector<
    StateIn,
    StateOut,
    MapFunc: Fn(&StateIn) -> StateOut,
    Updater: Fn(StateOut, &mut StateIn),
    Child: Component<StateOut>,
> {
    updater: Updater,
    mapper: MapFunc,
    child: Child,
    _t: PhantomData<StateIn>,
    _u: PhantomData<StateOut>,
}
impl<
        StateIn,
        StateOut,
        MapFunc: Fn(&StateIn) -> StateOut,
        Updater: Fn(StateOut, &mut StateIn),
        Child: Component<StateOut>,
    > Component<StateIn> for Selector<StateIn, StateOut, MapFunc, Updater, Child>
{
    fn process(&mut self, state: &mut StateIn) {
        let mut mapped_state = (self.mapper)(state);
        self.child.process(&mut mapped_state);
        (self.updater)(mapped_state, state)
    }

    fn render(&self, props: &StateIn) {
        let mapped_state = (self.mapper)(props);
        self.child.render(&mapped_state)
    }

    type Input = (MapFunc, Updater, Child);

    fn instantiate(input: Self::Input) -> Self {
        Self::new(input.0, input.1, input.2)
    }
    fn ui(&mut self, ui: &mut macroquad::ui::Ui, state: &mut StateIn) {
        let mut mapped_state = (self.mapper)(state);
        self.child.ui(ui, &mut mapped_state);
        (self.updater)(mapped_state, state)
    }
}
impl<
        StateIn,
        StateOut,
        MapFunc: Fn(&StateIn) -> StateOut,
        Updater: Fn(StateOut, &mut StateIn),
        Child: Component<StateOut>,
    > Selector<StateIn, StateOut, MapFunc, Updater, Child>
{
    pub fn new(map: MapFunc, updater: Updater, child: Child) -> Self {
        Self {
            updater,
            mapper: map,
            child,
            _t: PhantomData,
            _u: PhantomData,
        }
    }
}
